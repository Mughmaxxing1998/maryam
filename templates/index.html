<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Letter for You</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Playfair Display -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'sage': '#CCD5AE',
                        'eggshell': '#E9EDC9',
                        'cream': '#FEFAE0',
                        'peach': '#FAEDCD',
                        'tan': '#D4A373',
                        'terracotta-red': '#B85042',
                    },
                    fontFamily: {
                        'serif': ['Playfair Display', 'serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* The main wrapper centers everything and creates the 3D space */
        .envelope-wrapper {
            position: relative;
            width: 32rem; /* 512px */
            height: 20rem; /* 320px */
            max-width: 90vw;
            max-height: 56.25vw;
            margin: auto;
            perspective: 1000px;
        }
        /* Common style for all envelope parts */
        .envelope-part {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            will-change: transform; /* Performance hint for animations */
        }
        .envelope-back {
            background-color: #E9EDC9; /* eggshell */
            z-index: 0;
        }
        .flap {
            background-color: #D4A373; /* tan */
            overflow: hidden;
        }
        .flap::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #E9EDC9; /* eggshell */
            transform: scale(0.95);
        }
        .flap-left { clip-path: polygon(0% 0%, 50% 50%, 0% 100%); z-index: 2; }
        .flap-left::before { clip-path: polygon(0% 0%, 50% 50%, 0% 100%); }
        .flap-right { clip-path: polygon(100% 0%, 50% 50%, 100% 100%); z-index: 2; }
        .flap-right::before { clip-path: polygon(100% 0%, 50% 50%, 100% 100%); }
        .flap-bottom { clip-path: polygon(0% 100%, 50% 50%, 100% 100%); z-index: 3; }
        .flap-bottom::before { clip-path: polygon(0% 100%, 50% 50%, 100% 100%); }
        .flap-top {
            clip-path: polygon(0% 0%, 50% 50%, 100% 0%);
            transform-origin: top;
            z-index: 3;
            transition: transform 0.7s ease-in-out, z-index 0s 0.7s;
        }
        .flap-top::before { clip-path: polygon(0% 0%, 50% 50%, 100% 0%); }
        .heart-seal {
            background-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            box-shadow: none;
        }

        /* This is the paper that stays behind and animates its size */
        .letter-clone {
            position: absolute;
            background-color: #FEFAE0; /* cream */
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            /* Animate width, height, and position instead of transform */
            transition: width 0.8s, height 0.8s, top 0.8s, left 0.8s;
            transition-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bounce effect */
        }

        /* Wrapper for the content that fades in */
        .content-wrapper {
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .content-wrapper.visible { opacity: 1; }

        .letter-content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
            position: relative; /* Needed for page positioning */
            overflow: hidden; /* Hide sliding pages */
        }

        /* --- PAGE SLIDING ANIMATION --- */
        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            /* Default state is off-screen to the right */
            transform: translateX(100%);
            transition: transform 0.6s cubic-bezier(0.45, 0, 0.55, 1);
        }
        .page.active {
            /* Active page is centered */
            transform: translateX(0);
        }
        .page.prev {
            /* Pages that have been passed are off-screen to the left */
            transform: translateX(-100%);
        }

        .pagination-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem 1rem;
            box-sizing: border-box;
        }
        .page-btn {
            background: none; border: none; cursor: pointer; color: #D4A373; transition: color 0.3s;
        }
        .page-btn:hover:not(:disabled) { color: #B85042; }
        .page-btn:disabled { color: #CCD5AE; cursor: not-allowed; }

        /* ---- ANIMATION STATES ---- */
        .flap-top.open { transform: rotateX(180deg); z-index: 0; }
        .heart-seal.open { opacity: 0; transform: scale(0.5); }
        .fall {
             transition: transform 1.5s cubic-bezier(0.95, 0.05, 0.795, 0.035);
             transform: translateY(150vh);
        }
        .flap-top.fall { transform: translateY(150vh) rotateX(180deg); }

        /* --- GAME OF 15 STYLES --- */
        .game-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 90%; /* Adjust as needed */
            max-width: 400px; /* Max size of the game */
            aspect-ratio: 1 / 1; /* Keep it square */
            gap: 5px;
            padding: 5px;
            background-color: #D4A373; /* tan */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            margin: auto; /* Center in the page content area */
        }
        .game-tile {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #FEFAE0; /* cream */
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden; /* Ensure images don't spill out */
            position: absolute; /* For smooth animation using transform */
            transition: transform 0.3s ease-in-out; /* Animation for movement */
            will-change: transform; /* Performance hint */
        }
        .game-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the tile area */
        }
        .game-tile.blank {
            background-color: #CCD5AE; /* sage, or a slightly darker shade of game-container */
            cursor: default;
        }
        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.5rem;
            text-align: center;
            z-index: 100; /* Make sure it's on top */
        }
    </style>
</head>
<body class="bg-peach font-serif antialiased overflow-hidden">

    <div class="min-h-screen flex items-center justify-center">
        <div id="envelope-wrapper" class="envelope-wrapper cursor-pointer">
            <!-- Envelope parts -->
            <div id="envelope-back" class="envelope-part envelope-back"></div>
            <div id="flap-left" class="envelope-part flap flap-left"></div>
            <div id="flap-right" class="envelope-part flap flap-right"></div>
            <div id="flap-bottom" class="envelope-part flap flap-bottom"></div>
            <div id="flap-top" class="envelope-part flap flap-top"></div>
            <div id="heart" class="envelope-part heart-seal">
                <svg class="w-20 h-20 text-terracotta-red" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"></path></svg>
            </div>
        </div>
    </div>

    <script>
        const wrapper = document.getElementById('envelope-wrapper');
        const flapTop = document.getElementById('flap-top');
        const heart = document.getElementById('heart');

        const fallingParts = Array.from(document.querySelectorAll('.envelope-part'));

        const pageContents = [
            "<div id='game-of-15-placeholder'></div>", // Placeholder for the game
            "This is the second page, after the puzzle!",
            "More content can go here...",
            "And here as well.",
            "The final page."
        ];
        let currentPage = 0;
        let isOpen = false;
        let gameInitialized = false; // Flag to ensure game is initialized only once

        // --- GAME OF 15 LOGIC ---
        const GRID_SIZE = 4;
        let board = []; // 2D array representing the board state
        let blankPos = { row: -1, col: -1 };

        function countInversions(arr) {
            let inversions = 0;
            const flatArr = arr.filter(num => num !== 0); // Exclude blank (0)
            for (let i = 0; i < flatArr.length - 1; i++) {
                for (let j = i + 1; j < flatArr.length; j++) {
                    if (flatArr[i] > flatArr[j]) {
                        inversions++;
                    }
                }
            }
            return inversions;
        }

        function isSolvable(tiles, blankRow) {
            // tiles is a 1D array of numbers, 0 represents blank
            const inversions = countInversions(tiles);
            // Grid width is GRID_SIZE (4, which is even)
            // If grid width is even:
            //   - An odd number of inversions means the blank is on an even row from the bottom (counting 1-up).
            //   - An even number of inversions means the blank is on an odd row from the bottom (counting 1-up).
            const blankRowFromBottom = GRID_SIZE - blankRow;
            if (inversions % 2 !== 0) { // Odd inversions
                return blankRowFromBottom % 2 === 0; // Blank on even row from bottom
            } else { // Even inversions
                return blankRowFromBottom % 2 !== 0; // Blank on odd row from bottom
            }
        }

        function shuffleBoard() {
            let tiles = Array.from({ length: GRID_SIZE * GRID_SIZE - 1 }, (_, i) => i + 1);
            tiles.push(0); // 0 represents the blank space

            do {
                // Fisher-Yates shuffle
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
                // Find blank position for solvability check
                const blankIndex = tiles.indexOf(0);
                const tempBlankPos = { row: Math.floor(blankIndex / GRID_SIZE), col: blankIndex % GRID_SIZE };
                // console.log("Trying shuffle, blank at:", tempBlankPos, "Inversions:", countInversions(tiles));
            } while (!isSolvable(tiles, Math.floor(tiles.indexOf(0) / GRID_SIZE)));

            board = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                board.push(tiles.slice(i * GRID_SIZE, (i + 1) * GRID_SIZE));
            }

            const blankIndex = tiles.indexOf(0);
            blankPos = { row: Math.floor(blankIndex / GRID_SIZE), col: blankIndex % GRID_SIZE };
            // console.log("Solvable shuffle found:", board, "Blank at:", blankPos);
        }


        function renderBoard(container) {
            // container.innerHTML = ''; // No longer clearing and rebuilding everything
            // container.style.display = 'grid'; // This is set in CSS, but we need to ensure it's relative for absolute children
            container.style.position = 'relative'; // Ensure container can anchor absolute tiles

            const tileElements = {}; // To store references to DOM elements for animation

            // Calculate tile size based on container dimensions
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            // Assuming gap is 5px as per CSS, and padding is 5px on each side of container
            const totalGapWidth = 5 * (GRID_SIZE - 1);
            const totalPaddingWidth = 5 * 2;
            const tileWidth = (containerWidth - totalGapWidth - totalPaddingWidth) / GRID_SIZE;
            const tileHeight = (containerHeight - totalGapWidth - totalPaddingWidth) / GRID_SIZE;
            const gap = 5; // as defined in CSS for .game-container gap

            if (container.children.length === 0) { // Initial render
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const tileValue = board[r][c];
                        const tileElement = document.createElement('div');
                        tileElement.classList.add('game-tile');
                        tileElement.dataset.value = tileValue; // Store value for identification
                        tileElement.dataset.row = r;
                        tileElement.dataset.col = c;

                        // Set initial position using transform
                        const xPos = c * (tileWidth + gap) + gap; // Add initial gap for first column
                        const yPos = r * (tileHeight + gap) + gap; // Add initial gap for first row
                        tileElement.style.width = `${tileWidth}px`;
                        tileElement.style.height = `${tileHeight}px`;
                        tileElement.style.transform = `translate(${xPos}px, ${yPos}px)`;

                        if (tileValue === 0) {
                            tileElement.classList.add('blank');
                            tileElements[`blank`] = tileElement; // Store blank tile separately
                        } else {
                            const img = document.createElement('img');
                            img.src = `/static/split_images/${tileValue}.png`;
                            img.alt = `Tile ${tileValue}`;
                            tileElement.appendChild(img);
                            tileElement.addEventListener('click', () => handleTileClick(parseInt(tileElement.dataset.row), parseInt(tileElement.dataset.col)));
                            tileElements[`tile-${tileValue}`] = tileElement;
                        }
                        container.appendChild(tileElement);
                    }
                }
            } else { // Subsequent updates (after a move) - only update positions
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const tileValue = board[r][c];
                        let tileElement;
                        if (tileValue === 0) {
                            tileElement = container.querySelector(`.game-tile[data-value="0"]`);
                             if (!tileElement) { // Should not happen if blank tile always exists
                                console.error("Blank tile DOM element not found during update!");
                                tileElement = container.querySelector(`.blank`); // Fallback
                            }
                        } else {
                            tileElement = container.querySelector(`.game-tile[data-value="${tileValue}"]`);
                        }

                        if (tileElement) {
                            const xPos = c * (tileWidth + gap) + gap;
                            const yPos = r * (tileHeight + gap) + gap;
                            tileElement.style.transform = `translate(${xPos}px, ${yPos}px)`;
                            tileElement.dataset.row = r; // Update data attributes
                            tileElement.dataset.col = c;

                            // Ensure click listeners are correct, especially if we were to re-assign blank status
                            if (tileValue !== 0 && !tileElement.onclick) {
                                tileElement.addEventListener('click', () => handleTileClick(r,c));
                            } else if (tileValue === 0 && tileElement.onclick) {
                                tileElement.onclick = null; // Remove click from new blank
                            }
                        } else {
                             console.error(`Tile element for value ${tileValue} not found during update! Board:`, board);
                        }
                    }
                }
            }

            if (checkWinCondition()) {
                displayWinMessage(container.parentElement);
            }
        }

        let isAnimating = false; // Flag to prevent multiple clicks during animation

        function handleTileClick(r, c) {
            if (isAnimating) return; // Don't process clicks if animation is in progress

            const dr = Math.abs(r - blankPos.row);
            const dc = Math.abs(c - blankPos.col);

            if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                isAnimating = true;

                const gameContainer = document.querySelector('#game-of-15-placeholder .game-container');
                const clickedTileValue = board[r][c];

                // Find DOM elements
                const clickedTileElement = gameContainer.querySelector(`.game-tile[data-value="${clickedTileValue}"]`);
                const blankTileElement = gameContainer.querySelector(`.game-tile.blank`);

                if (!clickedTileElement || !blankTileElement) {
                    console.error("Could not find tile elements for animation. Re-rendering.", clickedTileValue, blankPos);
                    // Fallback to full re-render if elements are not found (should not happen)
                    board[blankPos.row][blankPos.col] = board[r][c];
                    board[r][c] = 0;
                    blankPos = { row: r, col: c };
                    renderBoard(gameContainer);
                    isAnimating = false;
                    return;
                }

                // Calculate new positions for transform
                const tileWidth = clickedTileElement.offsetWidth;
                const tileHeight = clickedTileElement.offsetHeight;
                const gap = 5; // sync with CSS

                const newClickedX = blankPos.col * (tileWidth + gap) + gap;
                const newClickedY = blankPos.row * (tileHeight + gap) + gap;

                const newBlankX = c * (tileWidth + gap) + gap;
                const newBlankY = r * (tileHeight + gap) + gap;

                // Apply transforms to animate
                clickedTileElement.style.transform = `translate(${newClickedX}px, ${newClickedY}px)`;
                blankTileElement.style.transform = `translate(${newBlankX}px, ${newBlankY}px)`;

                // Update data attributes for position
                const oldBlankRow = blankPos.row;
                const oldBlankCol = blankPos.col;

                // After animation, update the board array and data attributes
                setTimeout(() => {
                    // Update board array
                    board[oldBlankRow][oldBlankCol] = clickedTileValue;
                    board[r][c] = 0;

                    // Update blankPos
                    blankPos = { row: r, col: c };

                    // Update data attributes and classes
                    clickedTileElement.dataset.row = oldBlankRow;
                    clickedTileElement.dataset.col = oldBlankCol;

                    blankTileElement.dataset.row = r;
                    blankTileElement.dataset.col = c;

                    // Swap classes and click handlers (conceptually)
                    // The blank tile becomes the image tile, the image tile becomes blank.
                    // For simplicity with current renderBoard, we'll just re-render relevant parts or ensure data is fine
                    // For now, the `renderBoard` on next click isn't called, so we must ensure state is correct
                    // The `blank` class and `img` content effectively "move" with the logical tile
                    // Let's ensure the DOM reflects the logical board for the next click's querySelector logic

                    // The tile that *was* blank now gets the image and click listener
                    blankTileElement.classList.remove('blank');
                    const img = document.createElement('img');
                    img.src = `/static/split_images/${clickedTileValue}.png`;
                    img.alt = `Tile ${clickedTileValue}`;
                    blankTileElement.innerHTML = ''; // Clear any old content
                    blankTileElement.appendChild(img);
                    blankTileElement.dataset.value = clickedTileValue; // It's no longer blank (value 0)
                    blankTileElement.addEventListener('click', () => handleTileClick(oldBlankRow, oldBlankCol));


                    // The tile that *was* clicked (and had an image) becomes blank
                    clickedTileElement.classList.add('blank');
                    clickedTileElement.innerHTML = ''; // Remove image
                    clickedTileElement.dataset.value = 0; // It's now blank
                    clickedTileElement.onclick = null; // Remove its click listener

                    isAnimating = false;
                    if (checkWinCondition()) {
                         displayWinMessage(gameContainer.parentElement);
                    }

                }, 300); // Corresponds to CSS transition duration
            }
        }

        function checkWinCondition() {
            let current = 1;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (r === GRID_SIZE - 1 && c === GRID_SIZE - 1) { // Last cell
                        return board[r][c] === 0; // Should be blank
                    }
                    if (board[r][c] !== current) {
                        return false;
                    }
                    current++;
                }
            }
            return true; // Should not be reached if blank is not last
        }

        function displayWinMessage(pageElement) {
            // Check if a win message already exists
            if (pageElement.querySelector('.win-message')) return;

            const message = document.createElement('div');
            message.className = 'win-message';
            message.textContent = 'Congratulations! You solved it!';
            pageElement.style.position = 'relative'; // Ensure pageElement can anchor the absolute message
            pageElement.appendChild(message);
        }

        function initializeGame() {
            if (gameInitialized) return;
            const placeholder = document.getElementById('game-of-15-placeholder');
            if (!placeholder) {
                console.error("Game placeholder not found!");
                return;
            }

            const gameContainer = document.createElement('div');
            gameContainer.className = 'game-container';
            placeholder.appendChild(gameContainer);

            shuffleBoard();
            renderBoard(gameContainer);
            gameInitialized = true;
        }
        // --- END GAME OF 15 LOGIC ---


        wrapper.addEventListener('click', () => {
            if (isOpen) return;
            isOpen = true;

            wrapper.classList.remove('cursor-pointer');

            // 1. Create a BLANK paper clone. It starts at the same size as the envelope.
            const letterClone = document.createElement('div');
            letterClone.className = 'letter-clone';
            letterClone.style.top = '0';
            letterClone.style.left = '0';
            letterClone.style.width = '100%';
            letterClone.style.height = '100%';
            wrapper.appendChild(letterClone);

            // 2. Animate the envelope opening.
            flapTop.classList.add('open');
            heart.classList.add('open');

            // 3. After opening, make all original parts fall away.
            setTimeout(() => {
                fallingParts.forEach(part => part.classList.add('fall'));

                setTimeout(() => {
                    fallingParts.forEach(part => part.style.display = 'none');
                }, 1500);

            }, 700);

            // 4. After the fall, animate the size of the BLANK paper.
            setTimeout(() => {
                const finalWidthRem = 80; // Target width in rem (32 * 2.5)
                const finalHeightRem = 50; // Target height in rem (20 * 2.5)
                const initialWidthRem = 32;
                const initialHeightRem = 20;

                letterClone.style.width = `${finalWidthRem}rem`;
                letterClone.style.height = `${finalHeightRem}rem`;
                // Adjust top/left to make it grow from the center
                letterClone.style.top = `-${(finalHeightRem - initialHeightRem) / 2}rem`;
                letterClone.style.left = `-${(finalWidthRem - initialWidthRem) / 2}rem`;
            }, 2200); // 700ms (open) + 1500ms (fall)

            // 5. AFTER resizing, create and fade in the content.
            setTimeout(() => {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'content-wrapper';

                let pagesHTML = pageContents.map((content, index) => {
                    // For the first page (game), we don't want the default paragraph styling
                    if (index === 0) {
                        return `<div class="page">${content}</div>`;
                    }
                    return `<div class="page">
                                <p class="text-4xl italic text-tan drop-shadow-lg">${content}</p>
                            </div>`;
                }).join('');

                contentWrapper.innerHTML = `
                    <div class="letter-content">${pagesHTML}</div>
                    <div class="pagination-controls">
                        <button class="page-btn" id="prev-btn">
                            <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                        </button>
                        <span id="page-indicator" class="text-tan text-lg"></span>
                        <button class="page-btn" id="next-btn">
                            <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                    </div>
                `;

                letterClone.appendChild(contentWrapper);
                setTimeout(() => contentWrapper.classList.add('visible'), 50);

                const prevButton = document.getElementById('prev-btn');
                const nextButton = document.getElementById('next-btn');
                const pageIndicator = document.getElementById('page-indicator');
                const pages = letterClone.querySelectorAll('.page');

                function updatePaging() {
                    pages.forEach((page, index) => {
                        page.classList.remove('active', 'prev');
                        if (index === currentPage) {
                            page.classList.add('active');
                            // Initialize game if it's the first page and not yet initialized
                            if (currentPage === 0 && !gameInitialized) {
                                initializeGame();
                            }
                        } else if (index < currentPage) {
                            page.classList.add('prev');
                        }
                    });
                    pageIndicator.textContent = `${currentPage + 1} / ${pageContents.length}`;
                    prevButton.disabled = currentPage === 0;
                    nextButton.disabled = currentPage === pageContents.length - 1;
                }

                prevButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentPage > 0) {
                        currentPage--;
                        updatePaging();
                    }
                });

                nextButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentPage < pageContents.length - 1) {
                        currentPage++;
                        updatePaging();
                    }
                });

                updatePaging(); // Initial setup
            }, 3000); // 2200ms (resize start) + 800ms (resize duration)
        });
    </script>

</body>
</html>
