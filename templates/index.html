<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Letter for You</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Playfair Display -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'sage': '#CCD5AE',
                        'eggshell': '#E9EDC9',
                        'cream': '#FEFAE0',
                        'peach': '#FAEDCD',
                        'tan': '#D4A373',
                        'terracotta-red': '#B85042',
                    },
                    fontFamily: {
                        'serif': ['Playfair Display', 'serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* The main wrapper centers everything and creates the 3D space */
        .envelope-wrapper {
            position: relative;
            width: 32rem; /* 512px */
            height: 20rem; /* 320px */
            max-width: 90vw;
            max-height: 56.25vw;
            margin: auto;
            perspective: 1000px;
        }
        /* Common style for all envelope parts */
        .envelope-part {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            will-change: transform; /* Performance hint for animations */
        }
        .envelope-back {
            background-color: #E9EDC9; /* eggshell */
            z-index: 0;
        }
        .flap {
            background-color: #D4A373; /* tan */
            overflow: hidden;
        }
        .flap::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #E9EDC9; /* eggshell */
            transform: scale(0.95);
        }
        .flap-left { clip-path: polygon(0% 0%, 50% 50%, 0% 100%); z-index: 2; }
        .flap-left::before { clip-path: polygon(0% 0%, 50% 50%, 0% 100%); }
        .flap-right { clip-path: polygon(100% 0%, 50% 50%, 100% 100%); z-index: 2; }
        .flap-right::before { clip-path: polygon(100% 0%, 50% 50%, 100% 100%); }
        .flap-bottom { clip-path: polygon(0% 100%, 50% 50%, 100% 100%); z-index: 3; }
        .flap-bottom::before { clip-path: polygon(0% 100%, 50% 50%, 100% 100%); }
        .flap-top {
            clip-path: polygon(0% 0%, 50% 50%, 100% 0%);
            transform-origin: top;
            z-index: 3;
            transition: transform 0.7s ease-in-out, z-index 0s 0.7s;
        }
        .flap-top::before { clip-path: polygon(0% 0%, 50% 50%, 100% 0%); }
        .heart-seal {
            background-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            box-shadow: none;
        }

        /* This is the paper that stays behind and animates its size */
        .letter {
            position: absolute;
            background-color: #FEFAE0; /* cream */
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            /* Animate width, height, and position instead of transform */
            transition: width 0.8s, height 0.8s, top 0.8s, left 0.8s;
            transition-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bounce effect */
        }

        /* Wrapper for the content that fades in */
        .content-wrapper {
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .content-wrapper.visible { opacity: 1; }

        .letter-content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
            position: relative; /* Needed for page positioning */
            overflow: hidden; /* Hide sliding pages */
        }

        /* --- PAGE SLIDING ANIMATION --- */
        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Allow items to stack vertically */
            align-items: center;
            justify-content: center;
            padding: 2rem;
            /* Default state is off-screen to the right */
            transform: translateX(100%);
            transition: transform 0.6s cubic-bezier(0.45, 0, 0.55, 1);
        }
        .page.active {
            /* Active page is centered */
            transform: translateX(0);
        }
        .page.prev {
            /* Pages that have been passed are off-screen to the left */
            transform: translateX(-100%);
        }

        .pagination-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem 1rem;
            box-sizing: border-box;
        }
        .page-btn {
            background: none; border: none; cursor: pointer; color: #D4A373; transition: color 0.3s;
        }
        .page-btn:hover:not(:disabled) { color: #B85042; }
        .page-btn:disabled { color: #CCD5AE; cursor: not-allowed; }

        /* ---- ANIMATION STATES ---- */
        .flap-top.open { transform: rotateX(180deg); z-index: 0; }
        .heart-seal.open { opacity: 0; transform: scale(0.5); }
        .fall {
             transition: transform 1.5s cubic-bezier(0.95, 0.05, 0.795, 0.035);
             transform: translateY(150vh);
        }
        .flap-top.fall { transform: translateY(150vh) rotateX(180deg); }

        /* --- GAME OF 15 STYLES --- */
        .game-title {
            font-family: 'Playfair Display', serif;
            color: #D4A373;
            font-size: 2.25rem; /* text-4xl */
            font-style: italic;
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 90%; /* Adjust as needed */
            max-width: 400px; /* Max size of the game */
            aspect-ratio: 1 / 1; /* Keep it square */
            gap: 5px;
            padding: 5px;
            background-color: #D4A373; /* tan */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            margin-bottom: 1.5rem; /* Space between game and buttons */
        }
        .game-tile {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #FEFAE0; /* cream */
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease-in-out; /* This enables the animation */
            overflow: hidden; /* Ensure images don't spill out */
        }
        .game-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the tile area */
            /* --- ADDED STYLES TO PREVENT DRAGGING/HIGHLIGHTING --- */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE10+/Edge */
            user-select: none;         /* Standard */
            pointer-events: none;      /* Prevent direct interaction with the image itself */
        }
        .game-tile.blank {
            background-color: #CCD5AE; /* sage, or a slightly darker shade of game-container */
            cursor: default;
        }
        .win-message {
            margin-top: 1.5rem; /* Space between reset button and message */
        }

        .game-controls {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        .game-button {
            font-family: 'Playfair Display', serif;
            color: #D4A373;
            background-color: #FEFAE0;
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            border: 2px solid #D4A373;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .game-button:hover {
            background-color: #D4A373;
            color: #FEFAE0;
        }

        /* --- WORD SEARCH GAME STYLES --- */
        #word-search-placeholder {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem; /* Space between game and word slots */
        }
        .word-search-grid {
            display: grid;
            grid-template-columns: repeat(10, auto); /* 10 columns */
            gap: 2px; /* Tiny gap between cells */
            background-color: #D4A373; /* tan - border/bg color */
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .word-search-cell {
            width: 2.5rem; /* Adjust size as needed */
            height: 2.5rem; /* Adjust size as needed */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #FEFAE0; /* cream */
            font-family: 'Arial', sans-serif; /* More readable font for letters */
            font-size: 1.25rem; /* Adjust as needed */
            color: #B85042; /* terracotta-red */
            cursor: pointer;
            user-select: none; /* Prevent text selection during drag */
            transition: background-color 0.2s ease;
        }
        .word-search-cell.selected {
            background-color: #CCD5AE; /* sage - for selection highlighting */
        }
        .word-search-cell.found {
            background-color: #A9B489; /* darker sage - for permanently found words */
            color: #FEFAE0; /* cream - for text on found cells */
            /* Add a subtle animation or effect for found words if desired */
        }
        .word-slots-container {
            display: flex;
            justify-content: center;
            gap: 1rem; /* Space between word slots */
            margin-top: 1rem;
        }
        .word-slot {
            background-color: #FEFAE0; /* cream */
            border: 2px dashed #D4A373; /* tan */
            border-radius: 6px;
            padding: 0.5rem 1rem;
            min-width: 60px; /* Minimum width for each slot */
            height: 2.5rem; /* Match cell height or adjust */
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Playfair Display', serif;
            font-size: 1.25rem; /* Adjust as needed */
            color: #D4A373; /* tan - for the placeholder or filled word */
            text-align: center;
            transition: all 0.5s ease-in-out;
            overflow: hidden; /* For the filling animation */
        }
        .word-slot .slot-char {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            display: inline-block; /* Allows transform and delay */
        }
        .word-slot.filled .slot-char {
            opacity: 1;
            transform: translateY(0);
        }

    </style>
</head>
<body class="bg-peach font-serif antialiased overflow-hidden">

    <div class="min-h-screen flex items-center justify-center">
        <div id="envelope-wrapper" class="envelope-wrapper cursor-pointer">
            <!-- Envelope parts -->
            <div id="envelope-back" class="envelope-part envelope-back"></div>
            <div id="flap-left" class="envelope-part flap flap-left"></div>
            <div id="flap-right" class="envelope-part flap flap-right"></div>
            <div id="flap-bottom" class="envelope-part flap flap-bottom"></div>
            <div id="flap-top" class="envelope-part flap flap-top"></div>
            <div id="heart" class="envelope-part heart-seal">
                <svg class="w-20 h-20 text-terracotta-red" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"></path></svg>
            </div>
        </div>
    </div>

    <script>
        const wrapper = document.getElementById('envelope-wrapper');
        const flapTop = document.getElementById('flap-top');
        const heart = document.getElementById('heart');

        const fallingParts = Array.from(document.querySelectorAll('.envelope-part'));

        const pageContents = [
             // --- MODIFIED GAME PAGE STRUCTURE ---
            `
                <h2 class="game-title">LOBSTAR!!!</h2>
                <div id='game-of-15-placeholder'></div>
                <div class="game-controls">
                    <button id="reset-btn" class="game-button">Reset</button>
                </div>
            `,
            `
                <div class="text-center">
                    <h3 class="text-2xl italic text-tan mb-4">what's our inside joke again?</h3>
                    <div id="word-search-placeholder" class="mb-4"></div>
                    <div class="flex justify-center space-x-4">
                        <div class="word-slot" data-word="you"></div>
                        <div class="word-slot" data-word="are"></div>
                        <div class="word-slot" data-word="the"></div>
                        <div class="word-slot" data-word="joke"></div>
                    </div>
                    <div id="ws-completion-message" class="text-2xl text-terracotta-red mt-4" style="display: none;"></div>
                    <button id="ws-reset-btn" class="game-button mt-4" style="display: none;">Play Again?</button>
                </div>
            `,
            "More content can go here...",
            "And here as well.",
            "The final page."
        ];
        let currentPage = 0;
        let isOpen = false;
        let game15Initialized = false; // Renamed for clarity
        let wordSearchInitialized = false;

        // --- WORD SEARCH GAME LOGIC ---
        const WS_GRID_SIZE = 10;
        const wsWords = ["YOU", "ARE", "THE", "JOKE"]; // Words are uppercase for easier comparison
        let wsGrid = [];
        let wsFoundWords = [];
        let wsIsSelecting = false;
        let wsCurrentSelection = []; // Stores {row, col, element} of selected cells
        let wsSelectionDirection = null; // Stores {dr, dc} for the current line selection

        function generateWsGrid() {
            wsGrid = Array(WS_GRID_SIZE).fill(null).map(() => Array(WS_GRID_SIZE).fill(''));
            // TODO: Implement word placement logic
            // TODO: Implement random letter filling
        }

        function canPlaceWord(word, row, col, dr, dc) {
            for (let i = 0; i < word.length; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r < 0 || r >= WS_GRID_SIZE || c < 0 || c >= WS_GRID_SIZE) return false; // Out of bounds
                if (wsGrid[r][c] !== '' && wsGrid[r][c] !== word[i]) return false; // Cell occupied by different letter
            }
            return true;
        }

        function placeWordInGrid(word) {
            const directions = [
                { dr: 0, dc: 1 },  // Horizontal
                { dr: 1, dc: 0 },  // Vertical
                { dr: 1, dc: 1 },  // Diagonal down-right
                { dr: 1, dc: -1 }, // Diagonal down-left
                // For more challenge, add reverse directions too
                // { dr: 0, dc: -1 }, // Horizontal (reversed)
                // { dr: -1, dc: 0 }, // Vertical (reversed)
                // { dr: -1, dc: -1}, // Diagonal up-left (reversed)
                // { dr: -1, dc: 1}   // Diagonal up-right (reversed)
            ];
            let placed = false;
            let attemptsPerWord = 0; // Overall attempts for this word
            const maxAttemptsPerWord = 100; // Prevent infinite loops for a single word

            while(!placed && attemptsPerWord < maxAttemptsPerWord) {
                attemptsPerWord++;
                // Shuffle directions to try them in a random order
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);

                for (const dir of shuffledDirections) {
                    // Try a few random start positions for this direction
                    let attemptsPerDirection = 0;
                    const maxAttemptsPerDirection = 20; // Try 20 random starts for a direction

                    while(attemptsPerDirection < maxAttemptsPerDirection) {
                        attemptsPerDirection++;
                        const row = Math.floor(Math.random() * WS_GRID_SIZE);
                        const col = Math.floor(Math.random() * WS_GRID_SIZE);

                        if (canPlaceWord(word, row, col, dir.dr, dir.dc)) {
                            for (let i = 0; i < word.length; i++) {
                                wsGrid[row + i * dir.dr][col + i * dir.dc] = word[i];
                            }
                            placed = true;
                            break; // Exit direction loop
                        }
                    }
                    if (placed) break; // Exit main placement loop if word is placed
                }
            }
            if (!placed) {
                console.error(`Could not place word: ${word} after ${maxAttemptsPerWord} attempts.`);
                // Potentially handle this error, e.g., by stopping game generation or alerting user.
                // For now, it will just leave the word out, and the grid might be incomplete.
            }
        }

        function fillRandomLetters() {
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            for (let r = 0; r < WS_GRID_SIZE; r++) {
                for (let c = 0; c < WS_GRID_SIZE; c++) {
                    if (wsGrid[r][c] === '') {
                        wsGrid[r][c] = alphabet[Math.floor(Math.random() * alphabet.length)];
                    }
                }
            }
        }

        function renderWsGrid(container) {
            container.innerHTML = ''; // Clear previous grid
            const gridElement = document.createElement('div');
            gridElement.className = 'word-search-grid';

            for (let r = 0; r < WS_GRID_SIZE; r++) {
                for (let c = 0; c < WS_GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'word-search-cell';
                    cell.textContent = wsGrid[r][c];
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // Mouse events for selection
                    cell.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        wsIsSelecting = true;
                        wsSelectionDirection = null; // Reset direction on new selection
                        wsCurrentSelection = [{ row: r, col: c, element: cell }];
                        cell.classList.add('selected');
                        // Clear any previous 'found' highlights if re-selecting over them
                        // cell.classList.remove('found'); // Optional: if you want to allow re-selection of found words for a new attempt.
                    });

                    cell.addEventListener('mouseenter', () => {
                        if (wsIsSelecting && wsCurrentSelection.length > 0) {
                            const lastSelected = wsCurrentSelection[wsCurrentSelection.length - 1];
                            const currentRow = parseInt(cell.dataset.row);
                            const currentCol = parseInt(cell.dataset.col);

                            // Prevent selecting the same cell again in the current drag
                            if (lastSelected.row === currentRow && lastSelected.col === currentCol) return;

                            // Check if this cell is already part of the current selection path (e.g. mousing back over)
                            const alreadyInSelectionPath = wsCurrentSelection.find(s => s.row === currentRow && s.col === currentCol);

                            if (wsCurrentSelection.length === 1) {
                                // This is the second cell, determine direction
                                const dr = Math.sign(currentRow - lastSelected.row);
                                const dc = Math.sign(currentCol - lastSelected.col);
                                // Allow only horizontal, vertical, or diagonal
                                if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1 && (dr !== 0 || dc !== 0)) {
                                    wsSelectionDirection = { dr, dc };
                                    if (!alreadyInSelectionPath) {
                                        wsCurrentSelection.push({ row: currentRow, col: currentCol, element: cell });
                                        cell.classList.add('selected');
                                    }
                                }
                            } else if (wsSelectionDirection) {
                                // Subsequent cells: must follow the established direction
                                const expectedRow = lastSelected.row + wsSelectionDirection.dr;
                                const expectedCol = lastSelected.col + wsSelectionDirection.dc;

                                if (currentRow === expectedRow && currentCol === expectedCol) {
                                    if (!alreadyInSelectionPath) {
                                        wsCurrentSelection.push({ row: currentRow, col: currentCol, element: cell });
                                        cell.classList.add('selected');
                                    }
                                } else {
                                    // If user deviates, current behavior is to stop extending.
                                    // Alternative: could try to "snap back" or reset selection. For now, just stops.
                                }
                            }
                            // If mousing back over a path, remove cells from selection if not the last one.
                            // This logic is tricky. For simplicity, current approach doesn't aggressively remove on mouse back.
                            // User must release mouse to finalize selection or start a new one if they went wrong.
                        }
                    });
                    gridElement.appendChild(cell);
                }
            }
            container.appendChild(gridElement);

            // Add mouseup listener to the document to handle ending selection
            // Ensure this listener is added only once or managed properly if grid is re-rendered
            const onMouseUp = () => {
                if (wsIsSelecting) {
                    wsIsSelecting = false;
                    checkWsSelection();
                    // Clear 'selected' class from all cells after check
                    wsCurrentSelection.forEach(sel => sel.element.classList.remove('selected'));
                    wsCurrentSelection = [];
                }
            };
            // Remove existing listener to prevent duplicates if this function is called multiple times
            document.removeEventListener('mouseup', onMouseUp);
            document.addEventListener('mouseup', onMouseUp);
        }

        function checkWsSelection() {
            if (wsCurrentSelection.length === 0) return;

            // Simple check: get selected string
            // More complex check would validate if selection is a straight/diagonal line
            let selectedString = "";
            wsCurrentSelection.forEach(s => selectedString += wsGrid[s.row][s.col]);

            const foundWord = wsWords.find(word => word === selectedString || word === selectedString.split('').reverse().join(''));

            if (foundWord && !wsFoundWords.includes(foundWord)) {
                wsFoundWords.push(foundWord);
                wsCurrentSelection.forEach(sel => {
                    sel.element.classList.add('found');
                    // Make found cells non-interactive for new selections if desired
                    // sel.element.style.pointerEvents = 'none'; // Example
                });
                animateWordSlot(foundWord);
                if (wsFoundWords.length === wsWords.length) {
                    const completionMessage = document.getElementById('ws-completion-message');
                    const wsResetButton = document.getElementById('ws-reset-btn');
                    if (completionMessage) {
                        completionMessage.textContent = "Congratulations! You found all the words!";
                        completionMessage.style.display = 'block';
                    }
                    if (wsResetButton) {
                        wsResetButton.style.display = 'inline-block';
                    }
                    const gridElement = document.querySelector('#word-search-placeholder .word-search-grid');
                    if (gridElement) {
                        gridElement.style.pointerEvents = 'none'; // Disable further interaction
                    }
                }
            }
        }

        function resetWsGame() {
            wsFoundWords = [];
            wsCurrentSelection = [];
            wsSelectionDirection = null;

            const gridContainer = document.getElementById('word-search-placeholder');
            const cells = gridContainer.querySelectorAll('.word-search-cell');
            cells.forEach(cell => {
                cell.classList.remove('found', 'selected');
                cell.style.pointerEvents = 'auto'; // Ensure cells are interactive again
            });

            const slots = document.querySelectorAll('.word-slot');
            slots.forEach(slot => {
                slot.innerHTML = ''; // Clear text
                slot.classList.remove('filled');
            });

            const completionMessage = document.getElementById('ws-completion-message');
            const wsResetButton = document.getElementById('ws-reset-btn');
            if (completionMessage) completionMessage.style.display = 'none';
            if (wsResetButton) wsResetButton.style.display = 'none';

            // Re-generate and render the grid for a full shuffle
            // This makes the "Play Again" more meaningful
            generateWsGrid();
            wsWords.forEach(word => placeWordInGrid(word.toUpperCase()));
            fillRandomLetters();
            renderWsGrid(gridContainer); // This function re-creates the grid element

            // After renderWsGrid, the grid element is new, so re-query and set pointerEvents
            const newGridElement = gridContainer.querySelector('.word-search-grid');
            if (newGridElement) {
                 newGridElement.style.pointerEvents = 'auto';
            }
        }

        function animateWordSlot(word) {
            const slot = document.querySelector(`.word-slot[data-word="${word.toLowerCase()}"]`);
            if (slot) {
                slot.innerHTML = ''; // Clear if there was any placeholder text
                word.split('').forEach((char, index) => {
                    const span = document.createElement('span');
                    span.className = 'slot-char';
                    span.textContent = char;
                    span.style.transitionDelay = `${index * 0.05}s`; // Stagger animation
                    slot.appendChild(span);
                });
                slot.classList.add('filled'); // Trigger animation
            }
        }


        function initializeWordSearchGame() {
            if (wordSearchInitialized) return;
            const placeholder = document.getElementById('word-search-placeholder');
            if (!placeholder) {
                console.error("Word search placeholder not found!");
                return;
            }
            generateWsGrid(); // Placeholder for now
            wsWords.forEach(word => placeWordInGrid(word.toUpperCase()));
            fillRandomLetters();
            renderWsGrid(placeholder);

            const wsResetButton = document.getElementById('ws-reset-btn');
            if (wsResetButton) {
                // Ensure listener isn't added multiple times if init is somehow called again
                wsResetButton.removeEventListener('click', resetWsGame);
                wsResetButton.addEventListener('click', resetWsGame);
            }
            wordSearchInitialized = true;
        }


        // --- GAME OF 15 LOGIC ---
        const GAME_15_GRID_SIZE = 4; // Changed to avoid conflict
        let board = [];
        let blankPos = { row: -1, col: -1 };

        function countInversions(arr) {
            let inversions = 0;
            const flatArr = arr.filter(num => num !== 0);
            for (let i = 0; i < flatArr.length - 1; i++) {
                for (let j = i + 1; j < flatArr.length; j++) {
                    if (flatArr[i] > flatArr[j]) {
                        inversions++;
                    }
                }
            }
            return inversions;
        }

        function isSolvable(tiles, blankRow) {
            const inversions = countInversions(tiles);
            // Correctly use GAME_15_GRID_SIZE
            if (GAME_15_GRID_SIZE % 2 === 1) { // Odd grid width
                return inversions % 2 === 0;
            } else { // Even grid width
                const blankRowFromBottom = GAME_15_GRID_SIZE - blankRow; // 0-indexed row from bottom
                if ((blankRowFromBottom + 1) % 2 === 0) { // Blank on an even row from bottom (1-indexed)
                    return inversions % 2 === 1;
                } else { // Blank on an odd row from bottom (1-indexed)
                    return inversions % 2 === 0;
                }
            }
        }

        function shuffleBoard() {
            let tiles = Array.from({ length: GAME_15_GRID_SIZE * GAME_15_GRID_SIZE - 1 }, (_, i) => i + 1);
            tiles.push(0); // 0 represents the blank tile

            let maxAttempts = 100; // Prevent infinite loop
            let attempt = 0;
            do {
                // Fisher-Yates shuffle
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
                const blankIndex = tiles.indexOf(0);
                // Correctly use GAME_15_GRID_SIZE
                blankPos = { row: Math.floor(blankIndex / GAME_15_GRID_SIZE), col: blankIndex % GAME_15_GRID_SIZE };
                attempt++;
            } while (!isSolvable(tiles, blankPos.row) && attempt < maxAttempts);

            if(attempt >= maxAttempts) {
                console.warn("Could not generate a solvable Game of 15 board. Using last shuffle.");
                // Fallback: just use the last shuffle. It might be solvable by chance or user can reset.
                // Or, could implement a known solvable shuffle here.
            }

            board = [];
            for (let i = 0; i < GAME_15_GRID_SIZE; i++) {
                // Correctly use GAME_15_GRID_SIZE
                board.push(tiles.slice(i * GAME_15_GRID_SIZE, (i + 1) * GAME_15_GRID_SIZE));
            }
            // blankPos is already set correctly from the loop
        }


        function renderBoard(container) {
            container.innerHTML = '';
            // container.style.display = 'grid'; // Already set by .game-container
            // The grid-template-columns and rows are set by .game-container css

            for (let r = 0; r < GAME_15_GRID_SIZE; r++) {
                for (let c = 0; c < GAME_15_GRID_SIZE; c++) { // Correctly use GAME_15_GRID_SIZE
                    const tileValue = board[r][c];
                    const tileElement = document.createElement('div');
                    tileElement.classList.add('game-tile');
            } else {
                return blankRowFromBottom % 2 !== 0;
            }
        }

        function shuffleBoard() {
            let tiles = Array.from({ length: GRID_SIZE * GRID_SIZE - 1 }, (_, i) => i + 1);
            tiles.push(0);

            do {
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
                const blankIndex = tiles.indexOf(0);
            } while (!isSolvable(tiles, Math.floor(tiles.indexOf(0) / GRID_SIZE)));

            board = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                board.push(tiles.slice(i * GRID_SIZE, (i + 1) * GRID_SIZE));
            }

            const blankIndex = tiles.indexOf(0);
            blankPos = { row: Math.floor(blankIndex / GRID_SIZE), col: blankIndex % GRID_SIZE };
        }


        function renderBoard(container) {
            container.innerHTML = '';
            container.style.display = 'grid';

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const tileValue = board[r][c];
                    const tileElement = document.createElement('div');
                    tileElement.classList.add('game-tile');
                    if (tileValue === 0) {
                        tileElement.classList.add('blank');
                    } else {
                        const img = document.createElement('img');
                        img.src = `static/split_images/${tileValue}.png`;
                        img.alt = `Tile ${tileValue}`;
                        img.draggable = false;
                        tileElement.appendChild(img);
                        tileElement.addEventListener('click', () => handleTileClick(r, c));
                    }
                    container.appendChild(tileElement);
                }
            }
            if (checkWinCondition()) {
                displayWinMessage();
            }
        }

        function handleTileClick(r, c) {
            const dr = Math.abs(r - blankPos.row);
            const dc = Math.abs(c - blankPos.col);

            const gameContainer = document.querySelector('#game-of-15-placeholder .game-container');
            if (!gameContainer) return;

            if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                const clickedTileIndex = r * GRID_SIZE + c;
                const clickedTileElement = gameContainer.children[clickedTileIndex];

                if (!clickedTileElement) return;

                const translateX = (blankPos.col - c) * 100;
                const translateY = (blankPos.row - r) * 100;

                clickedTileElement.style.transform = `translate(${translateX}%, ${translateY}%)`;
                clickedTileElement.style.zIndex = '10';
                gameContainer.style.pointerEvents = 'none';

                setTimeout(() => {
                    board[blankPos.row][blankPos.col] = board[r][c];
                    board[r][c] = 0;
                    blankPos = { row: r, col: c };
                    renderBoard(gameContainer);
                    gameContainer.style.pointerEvents = 'auto';
                }, 200);
            }
        }


        function checkWinCondition() {
            let current = 1;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (r === GRID_SIZE - 1 && c === GRID_SIZE - 1) {
                        return board[r][c] === 0;
                    }
                    if (board[r][c] !== current) {
                        return false;
                    }
                    current++;
                }
            }
            return true;
        }

        function displayWinMessage() {
            // Find the game controls container
            const gameControls = document.querySelector('.game-controls');
            if (!gameControls) return;

            // Check if a win message already exists to avoid duplicates
            if (document.querySelector('.win-message')) return;

            const message = document.createElement('div');
            message.className = 'win-message text-4xl italic text-tan drop-shadow-lg';
            message.textContent = 'Congratulations! You solved it!';

            // Insert the message after the game controls container
            gameControls.parentNode.insertBefore(message, gameControls.nextSibling);
        }

        function initializeGame15() { // Renamed
            if (game15Initialized) return; // Renamed
            const placeholder = document.getElementById('game-of-15-placeholder');
            if (!placeholder) {
                console.error("Game 15 placeholder not found!"); // Clarified
                return;
            }

            const gameContainer = document.createElement('div');
            gameContainer.className = 'game-container';
            placeholder.appendChild(gameContainer);

            shuffleBoard(); // Assumes this uses GAME_15_GRID_SIZE correctly
            renderBoard(gameContainer); // Assumes this uses GAME_15_GRID_SIZE correctly
            game15Initialized = true; // Renamed
        }
        // --- END GAME OF 15 LOGIC ---


        wrapper.addEventListener('click', () => {
            if (isOpen) return;
            isOpen = true;

            wrapper.classList.remove('cursor-pointer');

            const letter = document.createElement('div');
            letter.className = 'letter';
            letter.style.top = '0';
            letter.style.left = '0';
            letter.style.width = '100%';
            letter.style.height = '100%';
            wrapper.appendChild(letter);

            flapTop.classList.add('open');
            heart.classList.add('open');

            setTimeout(() => {
                fallingParts.forEach(part => part.classList.add('fall'));

                setTimeout(() => {
                    fallingParts.forEach(part => part.style.display = 'none');
                }, 1500);

            }, 700);

            setTimeout(() => {
                const finalWidthRem = 80;
                const finalHeightRem = 50;
                const initialWidthRem = 32;
                const initialHeightRem = 20;

                letter.style.width = `${finalWidthRem}rem`;
                letter.style.height = `${finalHeightRem}rem`;
                letter.style.top = `-${(finalHeightRem - initialHeightRem) / 2}rem`;
                letter.style.left = `-${(finalWidthRem - initialWidthRem) / 2}rem`;
            }, 2200);

            setTimeout(() => {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'content-wrapper';

                let pagesHTML = pageContents.map((content, index) => {
                    if (index > 0) {
                        return `<div class="page">
                                    <p class="text-4xl italic text-tan drop-shadow-lg">${content}</p>
                                </div>`;
                    }
                    // For the game page, the content is already structured
                    return `<div class="page">${content}</div>`;
                }).join('');

                contentWrapper.innerHTML = `
                    <div class="letter-content">${pagesHTML}</div>
                    <div class="pagination-controls">
                        <button class="page-btn" id="prev-btn">
                            <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                        </button>
                        <span id="page-indicator" class="text-tan text-lg"></span>
                        <button class="page-btn" id="next-btn">
                            <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                    </div>
                `;

                letter.appendChild(contentWrapper);
                setTimeout(() => contentWrapper.classList.add('visible'), 50);

                const prevButton = document.getElementById('prev-btn');
                const nextButton = document.getElementById('next-btn');
                const pageIndicator = document.getElementById('page-indicator');
                const pages = letter.querySelectorAll('.page');

                function updatePaging() {
                    pages.forEach((page, index) => {
                        page.classList.remove('active', 'prev');
                        if (index === currentPage) {
                            page.classList.add('active');
                            if (currentPage === 0 && !game15Initialized) { // Game 15 on page 0
                                initializeGame15();
                            } else if (currentPage === 1 && !wordSearchInitialized) { // Word Search on page 1
                                initializeWordSearchGame();
                            }
                        } else if (index < currentPage) {
                            page.classList.add('prev');
                        }
                    });
                    pageIndicator.textContent = `${currentPage + 1} / ${pageContents.length}`;
                    prevButton.disabled = currentPage === 0;
                    // --- REMOVED LOCK LOGIC ---
                    nextButton.disabled = currentPage === pageContents.length - 1;
                }

                prevButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentPage > 0) {
                        currentPage--;
                        updatePaging();
                    }
                });

                nextButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentPage < pageContents.length - 1) {
                        currentPage++;
                        updatePaging();
                    }
                });

                const resetButton = document.getElementById('reset-btn');

                if(resetButton) {
                    resetButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const gameContainer = document.querySelector('#game-of-15-placeholder .game-container');
                        const winMessage = document.querySelector('.win-message');
                        if(winMessage) winMessage.remove();
                        shuffleBoard();
                        renderBoard(gameContainer);
                    });
                }

                updatePaging(); // Initial setup
            }, 3000);
        });
    </script>

</body>
</html>
